// SPDX-FileCopyrightText: Copyright 2025 Fabio Iotti
// SPDX-License-Identifier: AGPL-3.0-only

using SimpleCollab.CodeAnalysis.Utility;

namespace SimpleCollab.CodeAnalysis.EnumJsonGenerator;

static class EnumMemberValueJsonConverterHelper
{
    public const string AttributeFullName =
        "SimpleCollab.CodeAnalysis.EnumJsonGenerator.EnumMemberValueJsonConverterAttribute";

    public static string AttributesSource { get; } =
        """
            /// <auto-generated/>

            #nullable enable

            using System;

            namespace SimpleCollab.CodeAnalysis.EnumJsonGenerator
            {
                /// <summary>
                /// Attribute to mark a class as a generator for a JSON serializer that uses
                /// the enum member value as a value.
                /// </summary>
                [AttributeUsage(AttributeTargets.Class)]
                internal class EnumMemberValueJsonConverterAttribute : Attribute
                {
                    public EnumMemberValueJsonConverterAttribute()
                    {
                    }
                }
            }

            """.ReplaceNewLines();

    public static string GenerateSource(EnumMemberValueJsonConverterData data) =>
        $$"""
            /// <auto-generated/>

            #nullable enable

            using System.Collections.Immutable;
            using System.Runtime.CompilerServices;
            using System.Text.Json;

            namespace {{data.Namespace}}
            {
                file static class JsonConverterValues
                {
                    internal static readonly ImmutableDictionary<string, {{data.EnumTypeName}}> s_s2v = new KeyValuePair<string, {{data.EnumTypeName}}>[]
                    {
            {{string.Join("", data.EnumMemberValues.Select(v => $$"""
                        KeyValuePair.Create({{v.Value}}, {{data.EnumTypeName}}.{{v.Name}}),

            """))}}
                    }.ToImmutableDictionary();

                    internal static readonly ImmutableDictionary<{{data.EnumTypeName}}, string> s_v2t = new KeyValuePair<{{data.EnumTypeName}}, string>[]
                    {
            {{string.Join("", data.EnumMemberValues.Select(v => $$"""
                        KeyValuePair.Create({{data.EnumTypeName}}.{{v.Name}}, {{v.Value}}),

            """))}}
                    }.ToImmutableDictionary();
                }

                partial {{data.TypeType}} {{data.TypeName}}
                {
                    public override {{data.EnumTypeName}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                    {
                        string? str = reader.GetString();
                        if (str is null || !JsonConverterValues.s_s2v.TryGetValue(str, out {{data.EnumTypeName}} value))
                            throw new InvalidOperationException($"Invalid {nameof({{data.EnumTypeName}})}: '{str}'");

                        return value;
                    }

                    public override void Write(Utf8JsonWriter writer, {{data.EnumTypeName}} value, JsonSerializerOptions options)
                    {
                        if (!JsonConverterValues.s_v2t.TryGetValue(value, out string? str))
                            throw new InvalidOperationException($"Unsupported {nameof({{data.EnumTypeName}})}: {value}");

                        writer.WriteStringValue(str);
                    }
                }
            }
            
            """.ReplaceNewLines();
}
