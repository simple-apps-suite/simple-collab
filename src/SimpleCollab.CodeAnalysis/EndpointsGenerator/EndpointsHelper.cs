// SPDX-FileCopyrightText: Copyright 2025 Fabio Iotti
// SPDX-License-Identifier: AGPL-3.0-only

using SimpleCollab.CodeAnalysis.Utility;

namespace SimpleCollab.CodeAnalysis.EndpointsGenerator;

static class EndpointsHelper
{
    public const string EndpointsGroupAttributeFullName =
        "SimpleCollab.CodeAnalysis.EndpointsGenerator.EndpointsGroupAttribute";

    public const string EndpointAttributeFullName =
        "SimpleCollab.CodeAnalysis.EndpointsGenerator.EndpointAttribute";

    public static string AttributesSource { get; } =
        """
            /// <auto-generated/>

            #nullable enable

            using System;
            using System.Diagnostics.CodeAnalysis;

            namespace SimpleCollab.CodeAnalysis.EndpointsGenerator
            {
                /// <summary>
                /// Attribute to mark a method as an endpoint.
                /// An extension method to map this endpoint will be generated at compile time.
                /// </summary>
                [AttributeUsage(AttributeTargets.Method)]
                internal class EndpointAttribute : Attribute
                {
                    public string Pattern { get; }

                    public string? Verb { get; init; }

                    public EndpointAttribute([StringSyntax("Route")] string pattern)
                    {
                        Pattern = pattern;
                    }
                }

                /// <summary>
                /// Attribute to mark a class as a group of endpoints.
                /// An extension method to map these endpoints will be generated at compile time.
                /// </summary>
                [AttributeUsage(AttributeTargets.Class)]
                internal class EndpointsGroupAttribute : Attribute
                {
                    public string Prefix { get; }

                    public EndpointsGroupAttribute([StringSyntax("Route")] string prefix)
                    {
                        Prefix = prefix;
                    }
                }
            }

            """.ReplaceNewLines();

    public static string GenerateEndpointSource(EndpointData data) =>
        $$"""
            /// <auto-generated/>

            #nullable enable

            using System.Runtime.CompilerServices;

            [CompilerGenerated]
            file interface IEndpoint
            {
                static abstract IEndpointConventionBuilder Map(IEndpointRouteBuilder endpoints);

                static IEndpointConventionBuilder Map<T>(IEndpointRouteBuilder endpoints)
                    where T : IEndpoint => T.Map(endpoints);
            }

            namespace {{data.Namespace}}
            {
                internal static partial class {{data.TypeType}}EndpointsExtensions
                {
                    /// <summary>
                    /// Adds a <see cref="RouteEndpoint"/> to the <see cref="IEndpointRouteBuilder"/> that matches HTTP
                    /// {{data.Verb?.ToUpperInvariant()}}{{(data.Verb is null ? "" : " ")}}requests
                    /// for the <c>{{data.Pattern}}</c> pattern.
                    /// </summary>
                    /// <param name="endpoints"></param>
                    /// <returns></returns>
                    [CompilerGenerated]
                    public static IEndpointConventionBuilder Map{{data.MethodName}}(this IEndpointRouteBuilder endpoints) =>
                        IEndpoint.Map<{{data.TypeName}}>(endpoints);
                }

                partial {{data.TypeType}} {{data.TypeName}} : IEndpoint
                {
                    [CompilerGenerated]
                    static IEndpointConventionBuilder IEndpoint.Map(IEndpointRouteBuilder endpoints) =>
                        endpoints.{{GetVerbMap(data.Verb)}}("{{data.Pattern}}", {{data.MethodName}});
                }
            }

            """.ReplaceNewLines();

    public static string GenerateEndpointsGroupSource(EndpointsGroupAndEndpointsData data) =>
        $$"""
            /// <auto-generated/>

            #nullable enable

            using System.Runtime.CompilerServices;

            namespace {{data.Group.Namespace}}
            {
                static partial class {{data.Group.TypeType}}EndpointMapExtensions
                {
                    /// <summary>
                    /// Creates a <see cref="RouteGroupBuilder"/> for defining endpoints
                    /// {{(string.IsNullOrEmpty(data.Group.Prefix) ? "" : $"all prefixed with the prefix <c>{data.Group.Prefix}</c> ")}}and
                    /// adds all the <see cref="RouteEndpoint"/>s contained in <see cref="{{data.Group.TypeName}}"/>.
                    /// </summary>
                    /// <param name="endpoints"></param>
                    /// <returns></returns>
                    [CompilerGenerated]
                    public static RouteGroupBuilder Map{{data.Group.TypeName}}(this IEndpointRouteBuilder endpoints)
                    {
                        RouteGroupBuilder group = endpoints.MapGroup("{{data.Group.Prefix}}");

            {{string.Join("", data.Endpoints.Select(e => $$"""
                        group.Map{{e.MethodName}}();

            """))}}
                        return group;
                    }
                }
            }

            """.ReplaceNewLines();

    static string GetVerbMap(string? type) =>
        type switch
        {
            { Length: > 0 } s =>
                $"Map{char.ToUpperInvariant(s[0])}{s.Substring(1).ToLowerInvariant()}",
            _ => "Map",
        };
}
